import { prisma } from "../index";import { SessionStatus } from "@prisma/client";export async function getAllSessions() {	try {		return await prisma.session.findMany();	} catch (error) {		console.error('Error fetching sessions:', error);		throw error;	}}export async function deleteSession(sessionId: string) {	try {		const session = await prisma.session.findUnique({			where: {				id: sessionId,			},			include: {				group: true,			},		});				if (!session) {			throw new Error('Session not found');		}				if (session.group) {			throw new Error('Cannot delete a session with a group attached');		}				const deletedSession = await prisma.session.delete({			where: {				id: sessionId,			},		});				return deletedSession;	} catch (error) {		console.error('Error deleting session:', error);		throw error;	}}export async function createSession(	theme: string,	duration: number,	startDate: Date,	endDate: Date,	price: number,	minimalClient: number,	status: SessionStatus) {	try {		const createdSession = await prisma.session.create({			data: {				theme,				duration,				startDate,				endDate,				price,				minimalClient,				status,			},		});				return createdSession;	} catch (error) {		console.error('Error creating session:', error);		throw error;	}}export async function joinSession(sessionId: string, email: string, numberOfPeople: number) {	try {		const session = await prisma.session.findUnique({			where: { id: sessionId },		});				if (!session) {			throw new Error('Session not found');		}				const group = await prisma.group.create({			data: {				email,				nbOfClient: numberOfPeople,				session: {					connect: { id: sessionId },				},			},		});				await prisma.session.update({			where: { id: sessionId },			data: { status: "reserved" },		});				console.log("group created");		return group;	} catch (error) {		console.error('Error joining session:', error);		throw error;	}}export async function getSessionStatus(sessionId: string) {	try {		const session = await prisma.session.findUnique({			where: { id: sessionId },			select: { status: true },		});				if (!session) {			throw new Error('Session not found');		}				return session.status;	} catch (error) {		console.error('Error retrieving session status:', error);		throw error;	}}export async function updateSession(	id: string,	theme: string,	duration: number,	startDate: Date,	endDate: Date,	price: number,	minimalClient: number,	status: SessionStatus) {	try {		const session = await prisma.session.findUnique({			where: { id },			include: { group: true },		});				if (session && session.group) {			throw new Error('Cannot update a session with a group already signed in.');		}				const updatedSession = await prisma.session.update({			where: { id },			data: {				theme,				duration,				startDate,				endDate,				price,				minimalClient,				status,			},		});				return updatedSession;	} catch (error) {		console.error('Error updating session:', error);		throw error;	}}